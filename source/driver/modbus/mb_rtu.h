/***********************************************************************
  [Version]		1.00
  [Author ]		huangbin
  [Date   ]		2022.5.23
  [E-mail ]		huangembed@163.com 
  [  Q Q  ]		405803243
************************************************************************/
#ifndef __MB_RTU_H__
#define	__MB_RTU_H__
#include "inc.h"

#ifdef __cplusplus
 extern "C" {
#endif /* __cplusplus */
//////////////////////////////////////////////////////////////////////////
/*
MODBUS 使用一个‘big-Endian’ 表示地址和数据项
ADU:application data unit 地址+功能码+数据+CRC
pdu:protocol data unit 功能码+数据
MODBUS帧格式：地址(1byte)+功能码(1byte)+数据(最大bytes)+CRC(2byte.低byte在前,计算对象为除CRC字节以外的全部字节)
有效地址：1-247,0是广播地址

1. 功能码: 1-255，
实际有效的功能码是0x01-0x7F，高为置1表示错误应答
用户功能码：65-72,100-110
正常响应信息有2个与正常响应不相同的区域：
功能代码区：
正常响应时，从机的响应功能代码区，带原查询的功能代码。所有功能代码的MSB为0(其值低于80H)。
不正常响应时，从机把功能代码的MSB置为1，使功能代码值大于80H，高于正常响应的值。这样，主机应用程序能识别不正常响应事件，能检查不正常代码的数据区。
数据区：
正常响应中，数据区含有(按查询要求给出的) 数据或统计值，
在不正常响应中，数据区为一个不正常代码，它说明从机产生不正常响应的条件和原因

Modbus 信息中的所有数据地址以零作为基准，各项数据的第一个数据地址的编号为0
如：在可编程控制器中“coil 1”在Modbus信息中其地址值表示为0000
1=ON; 0=OFF。

//数据模型
离散量输入 单个比特 只读 I/O 系统提供这种类型数据
线圈 单个比特 读写 通过应用程序改变这种类型数据
输入寄存器 16-比特字 只读 I/O 系统提供这种类型数据
保持寄存器 16-比特字 读写 通过应用程序改变这种类型数据

//不正常代码
代码  名称  		含义
01	不合法功能代码	从机接收的是一种不能执行功能代码。发出查询命令后，该代码指示无程序功能。
02	不合法数据地址	接收的数据地址，是从机不允许的地址。
03	不合法数据		查询数据区的值是从机不允许的值。
04	从机设备故障	从机执行主机请求的动作时出现不可恢复的错误。
05	确认			从机已接收请求处理数据，但需要较长的处理时间，为避免主机出现超时错误而发送该确认响应。主机以此再发送一个“查询程序完成”来决定从机是否已完成处理。
06	从机设备忙碌	从机正忙于处理一个长时程序命令，请求主机在从机空闲时发送信息。
07	否定			从机不能执行查询要求的程序功能时，该代码使用十进制13或14代码，向主机返回一个“不成功的编程请求”信息。主机应请求诊断从机的错误信息。
08	内存奇偶校验错误		从机读扩展内存中的数据时(20.21码)，发现有奇偶校验错误，主机按从机的要求重新发送数据请求。
0A  不可用网关路径  		与网关一起使用，指示网关不能为处理请求分配输入端口至输出端口的内部通信路径。通常意味着网关是错误配置的或过载的。
0B  网关目标设备响应失败 	与网关一起使用，指示没有从目标设备中获得响应。通常意味着设备未在网络中
*/
typedef enum {
	EX_CODE_01 = 1,	//不合法功能代码	
	EX_CODE_02 = 2, //不合法数据地址
	EX_CODE_03 = 3, //不合法数据
	EX_CODE_04 = 4, //从机设备故障
	EX_CODE_05 = 5, //确认
	EX_CODE_06 = 6, //从机设备忙碌
	EX_CODE_07 = 7, //否定
	EX_CODE_08 = 8, //内存奇偶校验错误
	EX_CODE_0A = 0x0a, //不可用网关路径
	EX_CODE_0B = 0x0b, //网关目标设备响应失败
}EX_CODE;
#define MODBUS_ADDR_BOARDCAST	0	//广播地址，所有从机都要响应
//解码后的命令数据结构
typedef	struct modbus_rtu {
	uint8_t		RxBuf[MDRX_MAX];			//接收buffer
	uint8_t		TxBuf[MDTX_MAX];			//发送buffer
	uint8_t		devAddr;	//设备地址
	uint8_t		funCode;	//功能码
	uint8_t		payloadLen;	//有效数据长度
	uint16_t	Total;		//接收的总数据(包含所有信息，完整的帧)
	uint16_t	crc;		//crc校验码
}MODBUS_RTU;
//配置数据
typedef	struct modbus_config {
	uint32_t	BaudRate;		//波特率
	uint16_t	time35_us;		//3.5个字符的超时时间
	uint8_t		UartFormat;		//通讯格式0=8n1,1=8O1,2=8E1,3=8N2
	uint8_t		DevAddr;		//本机地址
}MODBUS_CONFIG;
extern MODBUS_CONFIG mbCfg;
#define COIL_ON		0xFF00		//线圈闭合
#define COIL_OFF	0x0000		//线圈断开

//拷贝接收的数据到rtu单元来
extern uint16_t mbCopyDataToRtu(uint8_t *pBuf,uint16_t len);
//解码modbus数据
extern void mbDecodeData(void);
//初始化modbus配置信息
extern void mbConfigInit(void);
//////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/************************END OF FILE*************************************/

